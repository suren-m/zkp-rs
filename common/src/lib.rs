use std::{
    io::{Error, ErrorKind, Write},
    net::TcpStream,
};

use log::info;
use serde::Serialize;

pub mod request_dto;
pub mod response_dto;

// public info
// Used when client is making the register commit
// r1 = g^k, r2 = h^k
// where k is a random seed generated by client
// smaller value for convenience when computing y1 = g^x and y2 = h^x
pub const G: u128 = 1;
pub const H: u128 = 2;

pub fn write_and_flush_stream<T: Serialize>(stream: &mut TcpStream, data: T) -> Result<(), Error> {
    let j = serde_json::to_string(&data);
    if j.is_ok() {
        let data = j.unwrap();
        info!("writing to response stream");
        dbg!(&data);
        stream.flush().unwrap();
        // sending anything other than json string from client will result in connection reset
        stream.write(data.as_bytes()).unwrap();
        stream.flush().unwrap();
        Ok(())
    } else {
        return Err(Error::new(ErrorKind::Other, j.err().unwrap()));
    }
}
