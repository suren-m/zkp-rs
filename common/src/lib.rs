//! zkp_common includes public constants `G` and `H` and data transfer objects (DTOs) used between client and server. 
//! ### Constraints for `G` and `H` 
//! Smaller values set for convenience when computing `y1 = g^x` and `y2 = h^x`
//! ```rust
//! // public info
//! // Used when client is making the register commit
//! // r1 = g^k, r2 = h^k
//! // where k is a random seed generated by client
//! pub const G: u128 = 1;
//! pub const H: u128 = 2;
//! ```
//! 
//! Two types of DTOs used:
//! ### For Client Requests
//! ```rust
//! #[derive(Clone, Debug, Serialize, Deserialize)]
//! pub enum ClientRequest {
//!     Register(Username, Commits), // server will respond with a success or failure
//!     Authenticate(Username),      // server will respond with a challenge to this
//!     ProveAuthentication(Username, Answer), // server will respond with a sucess or failure
//!     CheckStatus(Username), // server will respond whether logged in or not. (called after Login flow)
//!}
//! ```
//! ### For Server Responses
//! ```rust 
//! #[derive(Clone, Debug, Serialize, Deserialize)]
//! pub enum ServerResponse {
//!     Success,
//!     Challenge(u32),
//!     Failure(String),
//! }
//! ```
//! ### Data Exchange Format
//! This crate also includes a helper function to write and flush data to stream. 
//! 
//! * For simplicity, `JSON` is used for data exchange
//! * This can be replaced by a binary based representation such as `Protocol Buffers` for better performance
use std::{
    io::{Error, ErrorKind, Write},
    net::TcpStream,
};

use log::info;
use serde::Serialize;

pub mod request_dto;
pub mod response_dto;

// public info
// Used when client is making the register commit
// r1 = g^k, r2 = h^k
// where k is a random seed generated by client
// smaller value for convenience when computing y1 = g^x and y2 = h^x
pub const G: u128 = 1;
pub const H: u128 = 2;

pub fn write_and_flush_stream<T: Serialize>(stream: &mut TcpStream, data: T) -> Result<(), Error> {
    let j = serde_json::to_string(&data);
    if j.is_ok() {
        let data = j.unwrap();
        info!("Writing to stream: {}", &data);
        stream.flush().unwrap();
        // sending anything other than json string from client will result in connection reset
        stream.write(data.as_bytes()).unwrap();
        stream.flush().unwrap();
        Ok(())
    } else {
        return Err(Error::new(ErrorKind::Other, j.err().unwrap()));
    }
}
